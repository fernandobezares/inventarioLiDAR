/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var visRBR = {"opacity":1,"bands":["RBR"],"min":-0.19869096176636125,"max":0.35520329206573686,"gamma":1},
    aoi = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-6.460222874858383, 42.02504222621329],
          [-6.460222874858383, 41.805331233203134],
          [-5.979571019389633, 41.805331233203134],
          [-5.979571019389633, 42.02504222621329]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// global variables 

// AOI Defined by external script
// Dates defined by external script
// start date 
// final date 

// -----------------------------------------
// start date pre
var starDatePre = ee.Date('2022-06-10');

// end dare pre 
var finalDatePre = ee.Date('2022-06-14');

// start date post
var startDatePost= ee.Date('2022-06-20');

// end date post fire
var finalDatePost= ee.Date('2022-06-30');

// cloud pixel percentage 
var cloudPixelPercentage = 20;


//---------- province of interest ---------
var regions = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");

var zamora = regions.filter(ee.Filter.and(ee.Filter.eq('ADM0_NAME', 'Spain'),ee.Filter.eq('ADM2_NAME', 'Zamora')));

Map.centerObject(zamora, 8);

//----------- functions -----------------

// SPECTRAL INDEXES 

// mask cloud
function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));
  return image.updateMask(mask);//.divide(10000);
}


// NDWI 
// mask water: ndwi= land<0<=water
function maskWater(image){
  var waterNDWI = image.normalizedDifference(['B3','B8']).lt(0);
  return image.updateMask(waterNDWI);
  }


// B12 resample (optional)
function resample(image){
  var b12 = image.select('B12');
  var proj = image.select('B2').projection();
  var b12res = b12.resample('bilinear').reproject(proj).rename('B12res');
  return image.addBands(b12res);
  }


// NBR pre - post
function addNBRpre(image) {
  var NBR = image.normalizedDifference(['B8','B12']).rename('NBRpre');
  return image.addBands(NBR);
  }
  
  
// post
function addNBRpost(image){
  var NBR = image.normalizedDifference(['B8','B12']).rename('NBRpost');
  return image.addBands(NBR);
  } 


// NDVI
function addNDVI(image) {
  var NDVI = image.normalizedDifference(['B8', 'B4']).rename('ndvi');
  return image.addBands(NDVI);
}


// calcRBR
function calcRBR (image){
  var rbr = image.expression(
    '(NBRpre - NBRpost)/(NBRpre + 1.001)',
    {
    'NBRpre': image.select('NBRpre'),
    'NBRpost': image.select('NBRpost')
    })
  .rename('RBR');
  
  return rbr;
}


// RdNBR
function caclRdNBR(image){
  
  var rdnbr = image.expression(
    '(NBRpre - NBRpost) / (NBRpreAbs)**0.5',
    {
    'NBRpre': imageIndex.select('NBRpre'),
    'NBRpost': imageIndex.select('NBRpost'),
    'NBRpreAbs': imageIndex.abs().select('NBRpre')
    })
  .rename('RdNBR');
  
  return rdnbr;
}


//  RECLASSIFICATION SEVERITY FUNCTIONS 

// RBR reclass
function RBRrec(RBR){
  
  // reclassifies the index in severity classes
  // 1- low severity 
  // 2- moderate 
  // 3- high
  
  var reclass = ee.Image(0)
                .where (RBR.gt(0.105), 1) 
                .where (RBR.gt(0.2), 2) 
                .where (RBR.gt(0.355), 3) 
                .rename('RBRclass');
  
  return reclass;
}

// RdNBR reclass
function RdNBRrec(RdNBR){
  
  // reclassifies the index in severity classes
  // 1- low severity 
  // 2- moderate 
  // 3- high
  
  
  var reclass = ee.Image(0) //ee.Image(RdNBRclass).where... computes a lot (out of memory)
                .where (RdNBR.gt(0.230), 1) 
                .where (RdNBR.gt(0.475), 2) 
                .where (RdNBR.gt(0.835), 3) 
                .rename('RdNBRclass');
  
  return reclass;
  
} 

// usgs dNBR reclass
function usgsDNBR(dNBR){
  
  // // reclassifies the index in burnt severity according to usgs : 
  // 1- regrowth high
  // 2- regrowth low 
  // 3- unburned 
  // 4- low severity 
  // 5- moderate--low 
  // 6- moderate-high 
  // 7- high

  
  var usgsReclass = ee.Image(0)
    .where(dNBR.lte(-0.250), 1)
    .where(dNBR.gt(-0.250),2)
    .where(dNBR.gt(-0.100),3)
    .where(dNBR.gt(0.100),4)
    .where(dNBR.gt(0.270),5)
    .where(dNBR.gt(0.440),6)
    .where(dNBR.gt(0.660),7)
    .rename('dNBRclass');
  
  return usgsReclass; // returns Image

}

// Manso reclassification function 
function mansoDNBR (dNBR) {
  
  // 1- low severity 
  // 2- moderate 
  // 3- high
  
  var mansoReclass = ee.Image(0)
    .where (dNBR.gt(0.160), 1) 
    .where (dNBR.gt(0.260), 2) 
    .where (dNBR.gt(0.481), 3) 
    .rename('dNBRclass2');
    
  return mansoReclass; // returns Image
}


// BVI 
/*
var BVIclass= ee.Image(BVI)
                  .where(BVI.gt(0.230), 1)
                  .where(BVI.gt(0.475), 2)
                  .where(BVI.gt(0.835), 3)
                  .rename('RdNBRclass')
                  .clip(aoi)
*/


// ZONAL STATISTICS FUNCTIONS 

// area calculator function
function indexArea(image){
  var ai = ee.Image.pixelArea().divide(10000).addBands(image);
  var aIndexDict = ai.reduceRegion({
    reducer: ee.Reducer.sum().group(1),
    geometry: aoi,
    scale: 10,
    maxPixels: 1e13
  });
  return aIndexDict; // returns dictionary
}

// calcualte the pine wood volume in a given area

function volumenArea(image){
  
  // call the lidar var script 
  var lidar = require('users/cesefor/inventarioForestal:LidarApp/inc/LiDARVars');
  
  // call the vol dataset vol
  var vol = lidar.c1.vcc;
  
  var volArea = vcc.unmask(0).addBands(image);
  var aIndexDict = volArea.reduceRegion({
    reducer: ee.Reducer.sum().group(1),
    geometry: aoi,
    scale: 10,
    maxPixels: 1e13
  });
  return aIndexDict; // returns dictionary
}



// extract values from the first band of a raster
function getUniqueValues (image){
  
  // get the first raster band
  var bandName = ee.String(image.bandNames().get(0));
  
  // computes frequency histogram
  var valDict= image.reduceRegion({
    reducer: ee.Reducer.frequencyHistogram(),
    geometry: aoi,
    scale: 10,
    maxPixels: 1e13
  });
  
  var uniques = ee.Dictionary(valDict.get(bandName)).keys().map(ee.Number.parse);
  
  return uniques; // returns list 
}


// function to obtain the area in ha from the cross between two categorical rasters
function getMasksByCrossedCategories(img1, img2){
  
  // get the unique values from each image
  var uvimg1 = getUniqueValues(img1);
  var uvimg2 = getUniqueValues(img2);
  
  // get the bandNames from teh images 
  var bnImg1 = ee.String(img1.bandNames().get(0));
  var bnImg2 = ee.String(img2.bandNames().get(0));
  
 
  // generate an image collection with the masks
  var maskCollection = ee.ImageCollection.fromImages(
      
      // loop over category list 1
      uvimg1.map(function (class1){
      
      // loop over category list 2
      return uvimg2.map(function (class2){
        
        // get mask of the crossed categories
        var mask = img1.eq(ee.Number(class1)).and(img2.eq(ee.Number(class2)));
        
         // new band Name 
        var newName = bnImg1.cat(ee.String(class1)).cat('_')
                            .cat(bnImg2).cat(ee.String(class2))
                            .replace('\\.0','','g'); 

        //return mask
          return ee.Image(1).updateMask(mask)
          .set ('bnImg1', class1)
          .set ('bnImg2', class2)
          .rename(newName);
          });
          
      }).flatten()
);
  
  return maskCollection.toBands(); // returns an Image
  
}

// function for calculation the area of the bands of one Image holding binary masks in its bands 
function calculateArea (img){
  
  // get area image in has
  var imgArea = img.multiply(ee.Image.pixelArea()).divide(10000);
  
  // calculate the aggregated area .sum() for a Given Region
  var areaD = imgArea.reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: aoi,
    scale: 10,
    maxPixels: 1e13
    });

  // the result of reduceRegion is a dictionary,
  // so it is needed to convert it into FeatureCollection (to export it)
  var dict = ee.Dictionary (areaD);
  var key = ee.Dictionary(areaD).keys();
  
  // eliminate the geometry for better export
  return ee.FeatureCollection(key.map(function(value){
    return ee.Feature(null, {
      'band': value,
      'area': dict.get(value)
    });
  })
  );
}

// Calculate the area given two rasters
// the function finds the crossed areas between them and calclautes teh area in has 
function categoricalZonalStatistics (img1,img2){
  
  // get the multiband Image Mask
  var mask = getMasksByCrossedCategories (img1,img2);
  
  // get area Values ready to export 
  var area = calculateArea(mask);
  
  return area;
  
  
}

function getSpectralIndexes(date, userAOI){
  // inputs: date from the fire perimeters and user defined region
  
  // user defined area
  var aoi = userAOI;
  
  // call the images and apply functions (masks and nbr)
  var preFire = ee.ImageCollection("COPERNICUS/S2_SR")
              .filter(ee.Filter.bounds(aoi))
              .filterDate(starDatePre, finalDatePre)
              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloudPixelPercentage))
              .map(maskS2clouds)
              .map(maskWater)
              //.map(resample)
              .map (addNBRpre)
              .select ('B.*','NBRpre');
              
              
  var postFire = ee.ImageCollection("COPERNICUS/S2_SR")
              .filter(ee.Filter.bounds(aoi))
              .filterDate(startDatePost, finalDatePost)
              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloudPixelPercentage))
              .map(maskS2clouds)
              .map(maskWater)
              //.map(resample)
              .map(addNBRpost)
              .select ('B.*', 'NBRpost');
              

  // creation of composites (pre- and post-)
  var imagePreFire = preFire.median();
  var imagePostFire = postFire.median();

  // add ndvi to prefire
   imagePreFire = addNDVI(imagePreFire);

  // merge of the pre- and post- images
  var imageIndex = imagePreFire.select('NBRpre').addBands(imagePostFire.select('NBRpost'));
  
  // RBR=(nbrpre-nbrpost/nbrpre+1.001)
  var RBR = calcRBR(imageIndex).clip(aoi);
  
  // RdNBR = (NBRpre-NBRpost)/|(NBRpre)|^0.5
  var RdNBR = caclRdNBR(imageIndex).clip(aoi);
  
  // BVI (burned vegetation index) = NDVIpre-fire - NBR post-fire
  var BVI = imagePreFire.select('ndvi').subtract(imagePostFire.select('NBRpost')).rename('BVI');
  
  // dNBR (NBRpre - NBRpost)
  var dNBR = imageIndex.select('NBRpre').subtract(imageIndex.select('NBRpost')).rename('dNBR');
  
  // create an Iamge with all the indexes
  var indexImage = ee.Image.cat(imageIndex, RBR, RdNBR, BVI, dNBR);
  
  return indexImage;
  
  
  
  
}
//






//------------- NBR calculation -----------------------

// call the images and apply functions (masks and nbr)
var preFire = ee.ImageCollection("COPERNICUS/S2_SR")
              .filter(ee.Filter.bounds(zamora))
              .filterDate(starDatePre, finalDatePre)
              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloudPixelPercentage))
              .map(maskS2clouds)
              .map(maskWater)
              //.map(resample)
              .map (addNBRpre)
              .select ('B.*','NBRpre');
              
              
var postFire = ee.ImageCollection("COPERNICUS/S2_SR")
              .filter(ee.Filter.bounds(zamora))
              .filterDate(startDatePost, finalDatePost)
              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', cloudPixelPercentage))
              .map(maskS2clouds)
              .map(maskWater)
              //.map(resample)
              .map(addNBRpost)
              .select ('B.*', 'NBRpost');
              
              

// creation of composites (pre- and post-)
var imagePreFire = preFire.median();
var imagePostFire = postFire.median();

// add ndvi to prefire
var imagePreFire = addNDVI(imagePreFire);

// merge of the pre- and post- images
var imageIndex = imagePreFire.select('NBRpre').addBands(imagePostFire.select('NBRpost'));


//------------ burn indexes calculation -------------

// RBR=(nbrpre-nbrpost/nbrpre+1.001)
var RBR = calcRBR(imageIndex).clip(zamora);

// RdNBR = (NBRpre-NBRpost)/|(NBRpre)|^0.5
var RdNBR = caclRdNBR(imageIndex).clip(zamora);

// BVI (burned vegetation index) = NDVIpre-fire - NBR post-fire
var BVI = imagePreFire.select('ndvi').subtract(imagePostFire.select('NBRpost')).rename('BVI');

// dNBR (NBRpre - NBRpost)
var dNBR = imageIndex.select('NBRpre').subtract(imageIndex.select('NBRpost')).rename('dNBR');



//------------------- reclasification and clip to aoi of indexes-------------

// determination of aoi //manually with a geometry
    //var imports= require('users/franciscogallego/Cesefor:Training/ForestFires')
    //print (imports.aoi,'aoi' )
    //Map.addLayer(ee.Geometry(imports))

// RBR: 
var RBRclass = RBRrec(RBR).clip(aoi);

// RdNBR 
var RdNBRclass = RdNBRrec(RdNBR).clip(aoi);

// dNBR Reclassifications
var dNBRclass = usgsDNBR(dNBR).clip(aoi);
  
// Manso et al: 
var dNBRclass2 = mansoDNBR(dNBR).clip(aoi);


//------------------ mfe rasters -----------------
// note: mfe for Sierra de la Culebra has been rasterized in QGIS (lulucf / species)


var mfeEspecies = ee.Image('users/franciscogallego/mfeEspecies').rename('especies');

var mfeLulucf = ee.Image('users/franciscogallego/mfeLulucf').rename('lulucf');

var mfeData = mfeEspecies.addBands(mfeLulucf);


//-------------------------areas calculation-------------------------

// 1. By severity class

// RBR
var aRBR = ee.Dictionary(indexArea(RBRclass));

// RdNBR
var aRdNBR = ee.Dictionary(indexArea(RdNBRclass));

// dNBR usgs
var adNBR = ee.Dictionary(indexArea(dNBRclass));

// dNBR Manso
var adNBR2 = ee.Dictionary(indexArea(dNBRclass2));


// 2. By severity class and lulucf value

// creation of the masks with the combination of lulucf classes and severity classes

// ------------------------------------------------
// applying the functions 
// RBR
var aAltRBRL = categoricalZonalStatistics(RBRclass, mfeLulucf);

// RdNBR
var aAltRdNBRL = categoricalZonalStatistics(RdNBRclass,mfeLulucf);

// dNBR
var aAltdNBRL = categoricalZonalStatistics(dNBRclass,mfeLulucf);

// dNBR Manso 
var aAltdNBRL2 = categoricalZonalStatistics(dNBRclass2,mfeLulucf);


// area values 
print (aAltRBRL, 'RBR lulufc areas');
print (aAltRdNBRL, 'RdNBR lulucf areas');
print (aAltdNBRL, 'dNBR lulucf areas');
print (aAltdNBRL2, 'dNBR2 lulucf areas');
print(aAltdNBRL2.getDownloadURL({format: 'csv',filename: 'dNBR2 lulucf areas'}));

/*
var dwonloadButton = ui.Button({
  label: 'Download CSV area',
  onClick: function(){
    var url = aAltdNBRL2.getDownloadURL({format: 'csv',filename: 'dNBR2 lulucf areas'})
    
    var downPanel = ui.Panel()
    var label = ui.Label(url)
    
    downPanel.add(label)
    
    Map.add(downPanel)
  
}
})

Map.add(dwonloadButton)


// add elements to the map
/*
Map.addLayer (imageIndex, {}, 'image index calculation');

// indexes
Map.addLayer (RBR, visRBR, 'RBR');
Map.addLayer (RdNBR, visRdNBR, 'RdNBR');
Map.addLayer (BVI, visBVI, 'BVI');
Map.addLayer(dNBR, visdNBR, 'dNBR');

// reclass
Map.addLayer(RBRclass, {}, 'reclassification RBR');
Map.addLayer(RdNBRclass, {}, 'reclassification RdNBR');
Map.addLayer(dNBRclass, {}, 'dNBR classes usgs');
Map.addLayer(dNBRclass2, {}, 'dNBR classes mediterranean');

// mfe
Map.addLayer(mfeData, {}, 'lulucf mfe');

// Masks 

Map.addLayer(iRBRLulucf);

*/


